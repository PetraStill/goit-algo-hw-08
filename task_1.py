"""
Модуль реалізує задачу мінімізації загальної вартості з'єднання мережевих
кабелів у один, використовуючи мінімальну бінарну купу (min-heap) з модуля
heapq.

На кожному кроці з'єднуються два найкоротші кабелі, вартість з'єднання
дорівнює сумі їх довжин, а новий кабель повертається до купи. Алгоритм має
часову складність O(n log n), де n — кількість кабелів.
"""

import heapq
from typing import Iterable, List


def min_total_connection_cost(cables: Iterable[int]) -> int:
    """
    Обчислює мінімальну суму витрат на послідовне з'єднання всіх кабелів в один.

    На кожному кроці з'єднує два найкоротші кабелі, додає вартість з'єднання
    до загальної суми й повертає новий кабель до мін-купи.

    :param cables: Ітерабельна послідовність довжин кабелів (невід’ємні цілі числа).
    :return: Мінімально можлива загальна вартість усіх з'єднань.
    """
    # Ініціалізуємо купу списком довжин кабелів
    heap: List[int] = list(cables)

    # Опрацьовуємо порожній набір кабелів
    if not heap:
        return 0

    # Перетворюємо список на мін-купу (min-heap)
    heapq.heapify(heap)

    total_cost = 0

    # Виконуємо з'єднання, поки в купі більше одного кабелю
    while len(heap) > 1:
        # Витягуємо два найкоротші кабелі
        a = heapq.heappop(heap)
        b = heapq.heappop(heap)

        # Об'єднуємо кабелі та додаємо вартість до загальної суми
        merged = a + b
        total_cost += merged

        # Додаємо новий кабель назад у купу
        heapq.heappush(heap, merged)

    return total_cost


if __name__ == "__main__":
    # Приклад використання
    lengths = [4, 3, 2, 6]
    print(f"Мінімальна сума витрат на послідовне з'єднання всіх кабелів в один: {min_total_connection_cost(lengths)}")  # Очікувано: 29
